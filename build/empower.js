/**
 * Modules in this bundle
 * @license
 * 
 * empower-assert:
 *   license: MIT
 *   author: Takuto Wada <takuto.wada@gmail.com>
 *   contributors: James Talmage
 *   homepage: http://github.com/twada/empower-assert
 *   version: 1.1.0
 * 
 * array-filter:
 *   license: MIT
 *   author: Julian Gruber <mail@juliangruber.com>
 *   maintainers: juliangruber <julian@juliangruber.com>
 *   homepage: https://github.com/juliangruber/array-filter
 *   version: 1.0.0
 * 
 * array-foreach:
 *   license: MIT
 *   author: Takuto Wada <takuto.wada@gmail.com>
 *   maintainers: twada <takuto.wada@gmail.com>
 *   homepage: https://github.com/twada/array-foreach
 *   version: 1.0.1
 * 
 * array-map:
 *   license: MIT
 *   author: James Halliday <mail@substack.net>
 *   maintainers: substack <mail@substack.net>
 *   homepage: https://github.com/substack/array-map
 *   version: 0.0.0
 * 
 * array-some:
 *   license: MIT
 *   author: Takuto Wada <takuto.wada@gmail.com>
 *   maintainers: twada <takuto.wada@gmail.com>
 *   homepage: https://github.com/twada/array-some
 *   version: 1.0.0
 * 
 * call-signature:
 *   license: MIT
 *   author: James Talmage <james@talmage.io>
 *   maintainers: jamestalmage <james@talmage.io>, twada <takuto.wada@gmail.com>
 *   homepage: https://github.com/jamestalmage/call-signature#readme
 *   version: 0.0.2
 * 
 * define-properties:
 *   license: MIT
 *   author: Jordan Harband
 *   maintainers: ljharb <ljharb@gmail.com>
 *   homepage: https://github.com/ljharb/define-properties#readme
 *   version: 1.1.2
 * 
 * foreach:
 *   license: MIT
 *   author: Manuel Stofer <manuel@takimata.ch>
 *   maintainers: manuelstofer <manuel@takimata.ch>
 *   contributors: Manuel Stofer, Jordan Harband
 *   homepage: https://github.com/manuelstofer/foreach
 *   version: 2.0.5
 * 
 * function-bind:
 *   licenses: MIT
 *   author: Raynos <raynos2@gmail.com>
 *   maintainers: raynos <raynos2@gmail.com>
 *   contributors: Raynos
 *   homepage: https://github.com/Raynos/function-bind
 *   version: 0.1.0
 * 
 * has:
 *   licenses: MIT
 *   author: Thiago de Arruda <tpadilha84@gmail.com>
 *   maintainers: tarruda <tpadilha84@gmail.com>
 *   homepage: https://github.com/tarruda/has
 *   version: 0.0.1
 * 
 * object-create:
 *   licenses: MIT
 *   author: Thiago de Arruda <tpadilha84@gmail.com>
 *   maintainers: tarruda <tpadilha84@gmail.com>
 *   homepage: https://github.com/tarruda/object-create
 *   version: 0.1.0
 * 
 * object-define-property:
 *   licenses: MIT
 *   author: Thiago de Arruda <tpadilha84@gmail.com>
 *   maintainers: tarruda <tpadilha84@gmail.com>
 *   homepage: https://github.com/tarruda/object-define-property
 *   version: 0.1.0
 * 
 * object-keys:
 *   license: MIT
 *   author: Jordan Harband <ljharb@gmail.com>
 *   maintainers: ljharb <ljharb@gmail.com>
 *   contributors: Jordan Harband <ljharb@gmail.com>, Raynos <raynos2@gmail.com>, Nathan Rajlich <nathan@tootallnate.net>, Ivan Starkov <istarkov@gmail.com>, Gary Katsevman <git@gkatsev.com>
 *   homepage: https://github.com/ljharb/object-keys#readme
 *   version: 1.0.9
 * 
 * xtend:
 *   license: MIT
 *   author: Raynos <raynos2@gmail.com>
 *   maintainers: raynos <raynos2@gmail.com>
 *   contributors: Jake Verbaten, Matt Esch
 *   homepage: https://github.com/Raynos/xtend
 *   version: 4.0.1
 * 
 * This header is generated by licensify (https://github.com/twada/licensify)
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.empower = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw (f.code="MODULE_NOT_FOUND", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
/**
 * empower - Power Assert feature enhancer for assert function/object.
 *
 * https://github.com/power-assert-js/empower
 *
 * Copyright (c) 2013-2015 Takuto Wada
 * Licensed under the MIT license.
 *   https://github.com/power-assert-js/empower/blob/master/MIT-LICENSE.txt
 */
var defaultOptions = _dereq_('./lib/default-options');
var Decorator = _dereq_('./lib/decorator');
var capturable = _dereq_('./lib/capturable');
var create = _dereq_('object-create');
var slice = Array.prototype.slice;
var extend = _dereq_('xtend/mutable');
var define = _dereq_('define-properties');

/**
 * Enhance Power Assert feature to assert function/object.
 * @param assert target assert function or object to enhance
 * @param options enhancement options
 * @return enhanced assert function/object
 */
function empower (assert, options) {
    var typeOfAssert = (typeof assert);
    var enhancedAssert;
    if ((typeOfAssert !== 'object' && typeOfAssert !== 'function') || assert === null) {
        throw new TypeError('empower argument should be a function or object.');
    }
    if (isEmpowered(assert)) {
        return assert;
    }
    switch (typeOfAssert) {
    case 'function':
        enhancedAssert = empowerAssertFunction(assert, options);
        break;
    case 'object':
        enhancedAssert = empowerAssertObject(assert, options);
        break;
    default:
        throw new Error('Cannot be here');
    }
    define(enhancedAssert, capturable());
    return enhancedAssert;
}

function empowerAssertObject (assertObject, options) {
    var config = extend(defaultOptions(), options);
    var target = config.destructive ? assertObject : create(assertObject);
    var decorator = new Decorator(target, config);
    return extend(target, decorator.enhancement());
}

function empowerAssertFunction (assertFunction, options) {
    var config = extend(defaultOptions(), options);
    if (config.destructive) {
        throw new Error('cannot use destructive:true to function.');
    }
    var decorator = new Decorator(assertFunction, config);
    var enhancement = decorator.enhancement();
    var powerAssert;
    if (typeof enhancement === 'function') {
        powerAssert = function powerAssert () {
            return enhancement.apply(null, slice.apply(arguments));
        };
    } else {
        powerAssert = function powerAssert () {
            return assertFunction.apply(null, slice.apply(arguments));
        };
    }
    extend(powerAssert, assertFunction);
    return extend(powerAssert, enhancement);
}

function isEmpowered (assertObjectOrFunction) {
    return (typeof assertObjectOrFunction._capt === 'function') && (typeof assertObjectOrFunction._expr === 'function');
}

empower.defaultOptions = defaultOptions;
module.exports = empower;

},{"./lib/capturable":2,"./lib/decorator":4,"./lib/default-options":5,"define-properties":11,"object-create":16,"xtend/mutable":21}],2:[function(_dereq_,module,exports){
'use strict';

module.exports = function capturable () {
    var events = [];

    function _capt (value, espath) {
        events.push({value: value, espath: espath});
        return value;
    }

    function _expr (value, args) {
        var captured = events;
        events = [];
        var source = {
            content: args.content,
            filepath: args.filepath,
            line: args.line
        };
        if (args.generator) {
            source.generator = true;
        }
        if (args.async) {
            source.async = true;
        }
        return {
            powerAssertContext: {
                value: value,
                events: captured
            },
            source: source
        };
    }

    return {
        _capt: _capt,
        _expr: _expr
    };
};

},{}],3:[function(_dereq_,module,exports){
'use strict';

var slice = Array.prototype.slice;
var map = _dereq_('array-map');
var some = _dereq_('array-some');

function decorate (callSpec, decorator) {
    var func = callSpec.func;
    var thisObj = callSpec.thisObj;
    var numArgsToCapture = callSpec.numArgsToCapture;

    return function decoratedAssert () {
        var context, message, hasMessage = false, args = slice.apply(arguments);

        if (numArgsToCapture === (args.length - 1)) {
            message = args.pop();
            hasMessage = true;
        }

        var invocation = {
            thisObj: thisObj,
            func: func,
            values: args,
            message: message,
            hasMessage: hasMessage
        };

        if (some(args, isCaptured)) {
            invocation.values = map(args.slice(0, numArgsToCapture), function (arg) {
                if (isNotCaptured(arg)) {
                    return arg;
                }
                if (!context) {
                    context = {
                        source: arg.source,
                        args: []
                    };
                }
                context.args.push({
                    value: arg.powerAssertContext.value,
                    events: arg.powerAssertContext.events
                });
                return arg.powerAssertContext.value;
            });

            return decorator.concreteAssert(invocation, context);
        } else {
            return decorator.fallbackAssert(invocation);
        }
    };
}

function isNotCaptured (value) {
    return !isCaptured(value);
}

function isCaptured (value) {
    return (typeof value === 'object') &&
        (value !== null) &&
        (typeof value.powerAssertContext !== 'undefined');
}

module.exports = decorate;

},{"array-map":8,"array-some":9}],4:[function(_dereq_,module,exports){
'use strict';

var signature = _dereq_('call-signature');
var forEach = _dereq_('array-foreach');
var map = _dereq_('array-map');
var filter = _dereq_('array-filter');
var decorate = _dereq_('./decorate');


function Decorator (receiver, config) {
    this.receiver = receiver;
    this.config = config;
    this.onError = config.onError;
    this.onSuccess = config.onSuccess;
    this.signatures = map(config.patterns, signature.parse);
}

Decorator.prototype.enhancement = function () {
    var that = this;
    var container = this.container();
    forEach(filter(this.signatures, methodCall), function (matcher) {
        var methodName = detectMethodName(matcher.callee);
        if (typeof that.receiver[methodName] === 'function') {
            var callSpec = {
                thisObj: that.receiver,
                func: that.receiver[methodName],
                numArgsToCapture: numberOfArgumentsToCapture(matcher)
            };
            container[methodName] = decorate(callSpec, that);
        }
    });
    return container;
};

Decorator.prototype.container = function () {
    var basement = {};
    if (typeof this.receiver === 'function') {
        var candidates = filter(this.signatures, functionCall);
        if (candidates.length === 1) {
            var callSpec = {
                thisObj: null,
                func: this.receiver,
                numArgsToCapture: numberOfArgumentsToCapture(candidates[0])
            };
            basement = decorate(callSpec, this);
        }
    }
    return basement;
};

Decorator.prototype.concreteAssert = function (invocation, context) {
    var func = invocation.func;
    var thisObj = invocation.thisObj;
    var args = invocation.values;
    var message = invocation.message;
    var ret;
    try {
        ret = func.apply(thisObj, args.concat(message));
    } catch (e) {
        return this.onError({error: e, originalMessage: message, powerAssertContext: context});
    }
    return this.onSuccess({returnValue: ret, originalMessage: message, powerAssertContext: context});
};

Decorator.prototype.fallbackAssert = function (invocation) {
    var func = invocation.func;
    var thisObj = invocation.thisObj;
    var args = invocation.values;
    var message = invocation.message;
    args = args.concat(message);
    var ret;
    try {
        ret = func.apply(thisObj, args);
    } catch (e) {
        return this.onError({error: e, originalMessage: message, args: args});
    }
    return this.onSuccess({returnValue: ret, originalMessage: message, args: args});
};

function numberOfArgumentsToCapture (matcher) {
    var len = matcher.args.length;
    var lastArg;
    if (0 < len) {
        lastArg = matcher.args[len - 1];
        if (lastArg.name === 'message' && lastArg.optional) {
            len -= 1;
        }
    }
    return len;
}


function detectMethodName (callee) {
    if (callee.type === 'MemberExpression') {
        return callee.member;
    }
    return null;
}


function functionCall (matcher) {
    return matcher.callee.type === 'Identifier';
}


function methodCall (matcher) {
    return matcher.callee.type === 'MemberExpression';
}


module.exports = Decorator;

},{"./decorate":3,"array-filter":6,"array-foreach":7,"array-map":8,"call-signature":10}],5:[function(_dereq_,module,exports){
'use strict';

module.exports = function defaultOptions () {
    return {
        destructive: false,
        onError: onError,
        onSuccess: onSuccess,
        patterns: [
            'assert(value, [message])',
            'assert.ok(value, [message])',
            'assert.equal(actual, expected, [message])',
            'assert.notEqual(actual, expected, [message])',
            'assert.strictEqual(actual, expected, [message])',
            'assert.notStrictEqual(actual, expected, [message])',
            'assert.deepEqual(actual, expected, [message])',
            'assert.notDeepEqual(actual, expected, [message])',
            'assert.deepStrictEqual(actual, expected, [message])',
            'assert.notDeepStrictEqual(actual, expected, [message])'
        ]
    };
};

function onError (errorEvent) {
    var e = errorEvent.error;
    if (errorEvent.powerAssertContext && e.name === 'AssertionError') {
        e.powerAssertContext = errorEvent.powerAssertContext;
    }
    throw e;
}

function onSuccess(successEvent) {
    return successEvent.returnValue;
}

},{}],6:[function(_dereq_,module,exports){

/**
 * Array#filter.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Object=} self
 * @return {Array}
 * @throw TypeError
 */

module.exports = function (arr, fn, self) {
  if (arr.filter) return arr.filter(fn, self);
  if (void 0 === arr || null === arr) throw new TypeError;
  if ('function' != typeof fn) throw new TypeError;
  var ret = [];
  for (var i = 0; i < arr.length; i++) {
    if (!hasOwn.call(arr, i)) continue;
    var val = arr[i];
    if (fn.call(self, val, i, arr)) ret.push(val);
  }
  return ret;
};

var hasOwn = Object.prototype.hasOwnProperty;

},{}],7:[function(_dereq_,module,exports){
/**
 * array-foreach
 *   Array#forEach ponyfill for older browsers
 *   (Ponyfill: A polyfill that doesn't overwrite the native method)
 * 
 * https://github.com/twada/array-foreach
 *
 * Copyright (c) 2015 Takuto Wada
 * Licensed under the MIT license.
 *   http://twada.mit-license.org/
 */
'use strict';

module.exports = function forEach (ary, callback, thisArg) {
    if (ary.forEach) {
        ary.forEach(callback, thisArg);
        return;
    }
    for (var i = 0; i < ary.length; i+=1) {
        callback.call(thisArg, ary[i], i, ary);
    }
};

},{}],8:[function(_dereq_,module,exports){
module.exports = function (xs, f) {
    if (xs.map) return xs.map(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = xs[i];
        if (hasOwn.call(xs, i)) res.push(f(x, i, xs));
    }
    return res;
};

var hasOwn = Object.prototype.hasOwnProperty;

},{}],9:[function(_dereq_,module,exports){
/**
 * array-some
 *   Array#some ponyfill for older browsers
 *   (Ponyfill: A polyfill that doesn't overwrite the native method)
 * 
 * https://github.com/twada/array-some
 *
 * Copyright (c) 2015 Takuto Wada
 * Licensed under the MIT license.
 *   http://twada.mit-license.org/
 */
'use strict';

module.exports = function some (ary, callback, thisArg) {
    if (ary.some) {
        return ary.some(callback, thisArg);
    }
    for (var i = 0; i < ary.length; i+=1) {
        if (callback.call(thisArg, ary[i], i, ary)) {
            return true;
        }
    }
    return false;
};

},{}],10:[function(_dereq_,module,exports){
'use strict';
module.exports.parse = parse;
module.exports.generate = generate;

// TODO(jamestalmage): Allow full range of identifier characters instead of just ASCII
//
// This will likely require a build step
//
// SPEC: http://www.ecma-international.org/ecma-262/5.1/#sec-7.6
//
// TOOLING:
//    https://github.com/mathiasbynens/regenerate
//    https://www.npmjs.com/package/regjsgen

var regex = /^\s*(?:([A-Za-z$_][A-Za-z0-9$_]*)\s*\.)?\s*([A-Za-z$_][A-Za-z0-9$_]*)\s*\(\s*((?:[A-Za-z$_][A-Za-z0-9$_]*)|(?:\[\s*[A-Za-z$_][A-Za-z0-9$_]*\s*]))?((?:\s*,\s*(?:(?:[A-Za-z$_][A-Za-z0-9$_]*)|(?:\[\s*[A-Za-z$_][A-Za-z0-9$_]*\s*])))+)?\s*\)\s*$/;

function parse(str) {
	var match = regex.exec(str);
	if (!match) {
		return null;
	}

	var callee;
	if (match[1]) {
		callee = {
			type: 'MemberExpression',
			object: match[1],
			member: match[2]
		};
	} else {
		callee = {
			type: 'Identifier',
			name: match[2]
		};
	}

	var args = match[4] || '';
	args = args.split(',');
	if (match[3]) {
		args[0] = match[3];
	}
	var trimmed = [];
	args.forEach(function (str) {
		var optional = false;
		str = str.replace(/\s+/g, '');
		if (!str.length) {
			return;
		}
		if (str.charAt(0) === '[' && str.charAt(str.length - 1) === ']') {
			optional = true;
			str = str.substring(1, str.length - 1);
		}
		trimmed.push({
			name: str,
			optional: optional
		});
	});

	return {
		callee: callee,
		args: trimmed
	};
}

function generate(parsed) {
	var callee;
	if (parsed.callee.type === 'MemberExpression') {
		callee = [
			parsed.callee.object,
			'.',
			parsed.callee.member
		];
	} else {
		callee = [parsed.callee.name];
	}
	return callee.concat([
		'(',
		parsed.args.map(function (arg) {
			return arg.optional ? '[' + arg.name + ']' : arg.name;
		}).join(', '),
		')'
	]).join('');
}

},{}],11:[function(_dereq_,module,exports){
'use strict';

var keys = _dereq_('object-keys');
var foreach = _dereq_('foreach');
var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

var toStr = Object.prototype.toString;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
        /* eslint-disable no-unused-vars, no-restricted-syntax */
        for (var _ in obj) { return false; }
        /* eslint-enable no-unused-vars, no-restricted-syntax */
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		Object.defineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = props.concat(Object.getOwnPropertySymbols(map));
	}
	foreach(props, function (name) {
		defineProperty(object, name, map[name], predicates[name]);
	});
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;

},{"foreach":12,"object-keys":19}],12:[function(_dereq_,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],13:[function(_dereq_,module,exports){
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible "
var slice = Array.prototype.slice

module.exports = bind

function bind(that) {
    var target = this
    if (typeof target !== "function") {
        throw new TypeError(ERROR_MESSAGE + target)
    }
    var args = slice.call(arguments, 1)

    return function bound() {
        if (this instanceof bound) {
            var F = function () {}
            F.prototype = target.prototype
            var self = new F()

            var result = target.apply(
                self,
                args.concat(slice.call(arguments))
            )
            if (Object(result) === result) {
                return result
            }
            return self
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            )
        }
    }
}

},{}],14:[function(_dereq_,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;


module.exports = function has(obj, property) {
  return hasOwn.call(obj, property);
};

},{}],15:[function(_dereq_,module,exports){
var objectCreate = Object.create;


module.exports = function create(prototype, properties) {
  return objectCreate.call(Object, prototype, properties);
};

},{}],16:[function(_dereq_,module,exports){
/* jshint proto: true, scripturl: true */

var objectCreate = Object.create;
var defineProperties = _dereq_('object-define-property').defineProperties;

// Contributed by Brandon Benvie, October, 2012
var createEmpty;
var supportsProto = Object.prototype.__proto__ === null;
if (supportsProto || typeof document === 'undefined') {
  createEmpty = function () {
    return { "__proto__": null };
  };
} else {
  // In old IE __proto__ can't be used to manually set `null`, nor does
  // any other method exist to make an object that inherits from nothing,
  // aside from Object.prototype itself. Instead, create a new global
  // object and *steal* its Object.prototype and strip it bare. This is
  // used as the prototype to create nullary objects.
  createEmpty = function () {
    var iframe = document.createElement('iframe');
    var parent = document.body || document.documentElement;
    iframe.style.display = 'none';
    parent.appendChild(iframe);
    iframe.src = 'javascript:';
    var empty = iframe.contentWindow.Object.prototype;
    parent.removeChild(iframe);
    iframe = null;
    delete empty.constructor;
    delete empty.hasOwnProperty;
    delete empty.propertyIsEnumerable;
    delete empty.isPrototypeOf;
    delete empty.toLocaleString;
    delete empty.toString;
    delete empty.valueOf;
    empty.__proto__ = null;

    function Empty() {}
    Empty.prototype = empty;
    // short-circuit future calls
    createEmpty = function () {
      return new Empty();
    };
    return new Empty();
  };
}

function create(prototype, properties) {
  var object;
  function Type() {}  // An empty constructor.

  if (prototype === null) {
    object = createEmpty();
  } else {
    if (typeof prototype !== "object" && typeof prototype !== "function") {
      // In the native implementation `parent` can be `null` OR *any*
      // `instanceof Object`  (Object|Function|Array|RegExp|etc) Use `typeof`
      // tho, b/c in old IE, DOM elements are not `instanceof Object` like
      // they are in modern browsers. Using `Object.create` on DOM elements
      // is...err...probably inappropriate, but the native version allows for
      // it.
      // same msg as Chrome
      throw new TypeError("Object prototype may only be an Object or null"); 
    }
    Type.prototype = prototype;
    object = new Type();
    // IE has no built-in implementation of `Object.getPrototypeOf`
    // neither `__proto__`, but this manually setting `__proto__` will
    // guarantee that `Object.getPrototypeOf` will work as expected with
    // objects created using `Object.create`
    object.__proto__ = prototype;
  }

  if (properties !== void 0) {
    defineProperties(object, properties);
  }

  return object;
}


if (!objectCreate) {
  module.exports = create;
} else {
  module.exports = _dereq_('./index');
}

},{"./index":15,"object-define-property":18}],17:[function(_dereq_,module,exports){
var defProp = Object.defineProperty, defProps = Object.defineProperties;


module.exports = {
  defineProperty: function defineProperty(object, property, descriptor) {
    defProp.call(Object, object, property, descriptor);
  },
  defineProperties: function defineProperties(object, properties) {
    defProps.call(Object, object, properties);
  }
};

},{}],18:[function(_dereq_,module,exports){
/* jshint proto:true */
// ES5 15.2.3.6
// http://es5.github.com/#x15.2.3.6

// Patch for WebKit and IE8 standard mode
// Designed by hax <hax.github.com>
// related issue: https://github.com/es-shims/es5-shim/issues#issue/5
// IE8 Reference:
//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
// WebKit Bugs:
//     https://bugs.webkit.org/show_bug.cgi?id=36423

var has = _dereq_('has');
var bind = _dereq_('function-bind');

var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: ";
var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
  "on this javascript engine";

var defProp = Object.defineProperty, defProps = Object.defineProperties;
var call = Function.prototype.call;
var prototypeOfObject = Object.prototype;


// If JS engine supports accessors creating shortcuts.
var defineGetter;
var defineSetter;
var lookupGetter;
var lookupSetter;
var supportsAccessors;
if ((supportsAccessors = has(prototypeOfObject, "__defineGetter__"))) {
  defineGetter = bind.call(call, prototypeOfObject.__defineGetter__);
  defineSetter = bind.call(call, prototypeOfObject.__defineSetter__);
  lookupGetter = bind.call(call, prototypeOfObject.__lookupGetter__);
  lookupSetter = bind.call(call, prototypeOfObject.__lookupSetter__);
}

function doesDefinePropertyWork(object) {
  try {
    defProp.call(Object, object, "sentinel", {});
    return "sentinel" in object;
  } catch (exception) {
    // returns falsy
  }
}

// check whether defineProperty works if it's given. Otherwise,
// shim partially.
if (defProp) {
  var definePropertyWorksOnObject = doesDefinePropertyWork({});
  var definePropertyWorksOnDom = typeof document === "undefined" ||
    doesDefinePropertyWork(document.createElement("div"));
  if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
    var definePropertyFallback = defProp, definePropertiesFallback = defProps;
  }
}


function defineProperty(object, property, descriptor) {
  if ((typeof object !== "object" && typeof object !== "function") || object === null) {
    throw new TypeError(ERR_NON_OBJECT_TARGET + object);
  }
  if ((typeof descriptor !== "object" && typeof descriptor !== "function") || descriptor === null) {
    throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
  }
  // make a valiant attempt to use the real defineProperty
  // for I8's DOM elements.
  if (definePropertyFallback) {
    try {
      return definePropertyFallback.call(Object, object, property, descriptor);
    } catch (exception) {
      // try the shim if the real one doesn't work
    }
  }

  // If it's a data property.
  if (has(descriptor, "value")) {
    // fail silently if "writable", "enumerable", or "configurable"
    // are requested but not supported
    if (supportsAccessors && (lookupGetter(object, property) ||
                              lookupSetter(object, property)))
      {
        // As accessors are supported only on engines implementing
        // `__proto__` we can safely override `__proto__` while defining
        // a property to make sure that we don't hit an inherited
        // accessor.
        var prototype = object.__proto__;
        object.__proto__ = prototypeOfObject;
        // Deleting a property anyway since getter / setter may be
        // defined on object itself.
        delete object[property];
        object[property] = descriptor.value;
        // Setting original `__proto__` back now.
        object.__proto__ = prototype;
      } else {
        object[property] = descriptor.value;
      }
  } else {
    if (!supportsAccessors) {
      throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
    }
    // If we got that far then getters and setters can be defined !!
    if (has(descriptor, "get")) {
      defineGetter(object, property, descriptor.get);
    }
    if (has(descriptor, "set")) {
      defineSetter(object, property, descriptor.set);
    }
  }
  return object;
}


function defineProperties(object, properties) {
  // make a valiant attempt to use the real defineProperties
  if (definePropertiesFallback) {
    try {
      return definePropertiesFallback.call(Object, object, properties);
    } catch (exception) {
      // try the shim if the real one doesn't work
    }
  }
  for (var property in properties) {
    if (has(properties, property) && property !== "__proto__") {
      defineProperty(object, property, properties[property]);
    }
  }
  return object;
}


if (!defProp || definePropertyFallback) {
  module.exports = {
    defineProperty: defineProperty,
    defineProperties: defineProperties
  };
} else {
  module.exports = _dereq_('./index');
}

},{"./index":17,"function-bind":13,"has":14}],19:[function(_dereq_,module,exports){
'use strict';

// modified from https://github.com/es-shims/es5-shim
var has = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var slice = Array.prototype.slice;
var isArgs = _dereq_('./isArguments');
var hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString');
var hasProtoEnumBug = function () {}.propertyIsEnumerable('prototype');
var dontEnums = [
	'toString',
	'toLocaleString',
	'valueOf',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'constructor'
];
var equalsConstructorPrototype = function (o) {
	var ctor = o.constructor;
	return ctor && ctor.prototype === o;
};
var blacklistedKeys = {
	$console: true,
	$frame: true,
	$frameElement: true,
	$frames: true,
	$parent: true,
	$self: true,
	$webkitIndexedDB: true,
	$webkitStorageInfo: true,
	$window: true
};
var hasAutomationEqualityBug = (function () {
	/* global window */
	if (typeof window === 'undefined') { return false; }
	for (var k in window) {
		try {
			if (!blacklistedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
				try {
					equalsConstructorPrototype(window[k]);
				} catch (e) {
					return true;
				}
			}
		} catch (e) {
			return true;
		}
	}
	return false;
}());
var equalsConstructorPrototypeIfNotBuggy = function (o) {
	/* global window */
	if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
		return equalsConstructorPrototype(o);
	}
	try {
		return equalsConstructorPrototype(o);
	} catch (e) {
		return false;
	}
};

var keysShim = function keys(object) {
	var isObject = object !== null && typeof object === 'object';
	var isFunction = toStr.call(object) === '[object Function]';
	var isArguments = isArgs(object);
	var isString = isObject && toStr.call(object) === '[object String]';
	var theKeys = [];

	if (!isObject && !isFunction && !isArguments) {
		throw new TypeError('Object.keys called on a non-object');
	}

	var skipProto = hasProtoEnumBug && isFunction;
	if (isString && object.length > 0 && !has.call(object, 0)) {
		for (var i = 0; i < object.length; ++i) {
			theKeys.push(String(i));
		}
	}

	if (isArguments && object.length > 0) {
		for (var j = 0; j < object.length; ++j) {
			theKeys.push(String(j));
		}
	} else {
		for (var name in object) {
			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
				theKeys.push(String(name));
			}
		}
	}

	if (hasDontEnumBug) {
		var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

		for (var k = 0; k < dontEnums.length; ++k) {
			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
				theKeys.push(dontEnums[k]);
			}
		}
	}
	return theKeys;
};

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			return (Object.keys(arguments) || '').length === 2;
		}(1, 2));
		if (!keysWorksWithArguments) {
			var originalKeys = Object.keys;
			Object.keys = function keys(object) {
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				} else {
					return originalKeys(object);
				}
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./isArguments":20}],20:[function(_dereq_,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],21:[function(_dereq_,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}]},{},[1])(1)
});